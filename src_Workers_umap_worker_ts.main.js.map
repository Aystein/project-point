{"version":3,"file":"src_Workers_umap_worker_ts.main.js","sources":["./src/Layouts/ForceUtil.ts","./src/Layouts/Globals.ts","./src/Util.ts","./src/Workers/umap.worker.ts"],"sourcesContent":["import { ScaleLinear, scaleLinear } from 'd3-scale';\nimport { IRectangle } from '../WebGL/Math/Rectangle';\nimport { Simulation, SimulationLinkDatum } from 'd3-force';\nimport { POINT_RADIUS } from './Globals';\n\nexport function scaleToWorld(\n  area: IRectangle\n): [\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n] {\n  const worldX = scaleLinear()\n    .domain([0, 1])\n    .range([area.x, area.x + area.width]);\n\n  const worldY = scaleLinear()\n    .domain([0, 1])\n    .range([area.y, area.y + area.height]);\n\n  return [worldX, worldY];\n}\n\nexport function forceNormalizationNew(\n  area: IRectangle\n): [\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n  number\n] {\n  const factor = 500 / area.width;\n\n  const scaleX = scaleLinear()\n    .domain([0, 1])\n    .range([0, area.width * factor]);\n\n  const scaleY = scaleLinear()\n    .domain([0, 1])\n    .range([0, area.height * factor]);\n\n  const worldX = scaleLinear()\n    .domain([0, 1])\n    .range([area.x + area.width * 0.01, area.x + area.width * 0.99]);\n\n  const worldY = scaleLinear()\n    .domain([0, 1])\n    .range([area.y + area.height * 0.01, area.y + area.height * 0.99]);\n\n  return [scaleX, scaleY, worldX, worldY, POINT_RADIUS * factor];\n}\n\nexport function forceNormalization(\n  area: IRectangle\n): [ScaleLinear<number, number>, ScaleLinear<number, number>, number] {\n  const factor = 500 / area.width;\n\n  const scaleX = scaleLinear()\n    .domain([area.x, area.x + area.width])\n    .range([0, area.width * factor]);\n\n  const scaleY = scaleLinear()\n    .domain([area.y, area.y + area.height])\n    .range([0, area.height * factor]);\n\n  return [scaleX, scaleY, POINT_RADIUS * factor];\n}\n\nexport function convergeLayout<A, B extends SimulationLinkDatum<A>>(\n  simulation: Simulation<A, B>\n) {\n  for (\n    var i = 0,\n      n = Math.ceil(\n        Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())\n      );\n    i < n;\n    ++i\n  ) {\n    // console.log(\"TICK\")\n    simulation.tick();\n  }\n}\n","export const POINT_RADIUS = 0.012;\n","import { EntityId } from '@reduxjs/toolkit';\r\nimport { Boundaries, VectorLike } from './Interfaces';\r\nimport { ScaleLinear, scaleLinear } from 'd3-scale';\r\nimport { Rectangle } from './WebGL/Math/Rectangle';\r\n\r\nexport function isEntityId(value): value is EntityId {\r\n  return typeof value === 'string' || typeof value === 'number';\r\n}\r\n\r\nexport function getMinMax(values: number[]) {\r\n  let minX = Number.MAX_SAFE_INTEGER;\r\n  let maxX = Number.MIN_SAFE_INTEGER;\r\n\r\n  values.forEach((sample) => {\r\n    minX = Math.min(minX, sample);\r\n    maxX = Math.max(maxX, sample);\r\n  });\r\n\r\n  return [minX, maxX];\r\n}\r\n\r\nexport function getBounds(spatial: VectorLike[]): Boundaries {\r\n  // Get rectangle that fits around data set\r\n  let minX = 1000;\r\n  let maxX = -1000;\r\n  let minY = 1000;\r\n  let maxY = -1000;\r\n\r\n  spatial.forEach((sample) => {\r\n    minX = Math.min(minX, sample.x);\r\n    maxX = Math.max(maxX, sample.x);\r\n    minY = Math.min(minY, sample.y);\r\n    maxY = Math.max(maxY, sample.y);\r\n  });\r\n\r\n  return {\r\n    minX,\r\n    maxX,\r\n    minY,\r\n    maxY,\r\n    centerX: (minX + maxX) / 2,\r\n    centerY: (minY + maxY) / 2,\r\n    extentX: maxX - minX,\r\n    extentY: maxY - minY,\r\n  };\r\n}\r\n\r\nexport function spread(center: number, radius: number) {\r\n  return center - radius + Math.random() * 2 * radius;\r\n}\r\n\r\nexport function scaleInto(source: VectorLike[]): [VectorLike[], number] {\r\n  const bounds = getBounds(source);\r\n  const center = 10;\r\n\r\n  if (bounds.extentX >= bounds.extentY) {\r\n    const translateX = center - bounds.centerX;\r\n    const xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([bounds.minX + translateX, bounds.maxX + translateX])\r\n    const yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([center - bounds.extentY / 2, center + bounds.extentY / 2])\r\n\r\n    return [source.map((value) => ({\r\n      x: xScale(value.x),\r\n      y: yScale(value.y)\r\n    })), bounds.extentX];\r\n  }\r\n\r\n  if (bounds.extentX < bounds.extentY) {\r\n    const translateY = center - bounds.centerY;\r\n    const xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([center - bounds.extentX / 2, center + bounds.extentX / 2])\r\n    const yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([bounds.minY + translateY, bounds.maxY + translateY])\r\n\r\n    return [source.map((value) => ({\r\n      x: xScale(value.x),\r\n      y: yScale(value.y)\r\n    })), bounds.extentY];\r\n  }\r\n}\r\n\r\nexport function normalizeVectors(positions: VectorLike[]) {\r\n  const bounds = getBounds(positions);\r\n\r\n  let xScale: ScaleLinear<number, number>;\r\n  let yScale: ScaleLinear<number, number>;\r\n\r\n\r\n\r\n  if (bounds.extentX >= bounds.extentY) {\r\n    const scale = bounds.extentY / bounds.extentX;\r\n    xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([-bounds.extentX / 2, bounds.extentX / 2]);\r\n    yScale = scaleLinear()\r\n      .domain([bounds.minY, bounds.maxY])\r\n      .range([(-bounds.extentY / 2) * scale, (bounds.extentY / 2) * scale]);\r\n  } else {\r\n    const scale = bounds.extentX / bounds.extentY;\r\n    xScale = scaleLinear()\r\n      .domain([bounds.minX, bounds.maxX])\r\n      .range([(-bounds.extentX / 2) * scale, (bounds.extentX / 2) * scale]);\r\n    yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([-bounds.extentY / 2, bounds.extentY / 2]);\r\n  }\r\n\r\n  return positions.map((value) => ({ x: xScale(value.x), y: yScale(value.y) }));\r\n}\r\n\r\nexport function normalizeVectors01(positions: VectorLike[]) {\r\n  const bounds = getBounds(positions);\r\n\r\n  let xScale: ScaleLinear<number, number>;\r\n  let yScale: ScaleLinear<number, number>;\r\n\r\n  if (bounds.extentX >= bounds.extentY) {\r\n    const scale = bounds.extentY / bounds.extentX;\r\n    xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([0, 1]);\r\n    yScale = scaleLinear()\r\n      .domain([bounds.minY, bounds.maxY])\r\n      .range([1 - scale, scale]);\r\n  } else {\r\n    const scale = bounds.extentX / bounds.extentY;\r\n    xScale = scaleLinear()\r\n      .domain([bounds.minX, bounds.maxX])\r\n      .range([1 - scale, scale]);\r\n    yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([0, 1]);\r\n  }\r\n\r\n  return positions.map((value) => ({ x: xScale(value.x), y: yScale(value.y) }));\r\n}\r\n\r\n/**\r\n * Performs a test if a point is inside a polygon based on the idea from\r\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\r\n *\r\n * This method will not need the same start/end point since it wraps around the edges of the array\r\n *\r\n * @param {*} test a point to test against\r\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\r\n * @returns true if the point lies inside the polygon, false otherwise\r\n */\r\nexport function pointInPolygon(testx, testy, polygon) {\r\n  let intersections = 0;\r\n\r\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n    const [prevX, prevY] = polygon[j];\r\n    const [x, y] = polygon[i];\r\n\r\n    // count intersections\r\n    if (\r\n      y > testy != prevY > testy &&\r\n      testx < ((prevX - x) * (testy - y)) / (prevY - y) + x\r\n    ) {\r\n      intersections++;\r\n    }\r\n  }\r\n\r\n  // point is in polygon if intersection count is odd\r\n  return intersections & 1;\r\n}\r\n","/* eslint-disable no-restricted-globals */\r\nimport { UMAP } from 'umap-js';\r\nimport { scaleLinear } from 'd3-scale';\r\nimport { getMinMax, normalizeVectors01 } from '../Util';\r\nimport { VectorLike } from '../Interfaces';\r\nimport {\r\n  scaleToWorld,\r\n} from '../Layouts/ForceUtil';\r\nimport { LabelContainer } from '../Store/ModelSlice';\r\n\r\ninterface UMAPWorkerProps {\r\n  data: {\r\n    X;\r\n    D;\r\n    N;\r\n    area;\r\n    type;\r\n    Y_in: VectorLike[];\r\n    axis: 'x' | 'y' | 'xy';\r\n  };\r\n}\r\n\r\nself.onmessage = ({\r\n  data: { X, D, N, area, type, Y_in, axis },\r\n}: UMAPWorkerProps) => {\r\n  if (type !== 'init') {\r\n    return;\r\n  }\r\n\r\n  const nComponents = axis === 'xy' ? 2 : 1;\r\n\r\n  self.postMessage({\r\n    type: 'message',\r\n    message: 'Calculating embedding ...',\r\n  });\r\n\r\n  const umap = new UMAP({\r\n    nComponents,\r\n    nEpochs: 200,\r\n    nNeighbors: 15,\r\n  });\r\n  const embedding = umap.fit(X);\r\n\r\n  let Y: VectorLike[];\r\n  const labels: LabelContainer[] = [];\r\n\r\n  if (axis === 'x') {\r\n    const data = embedding.map((arr) => arr[0]);\r\n    const scale = scaleLinear().domain(getMinMax(data)).range([0, 1]);\r\n    Y = data.map((arr, i) => ({ x: scale(arr), y: Y_in[i].y }));\r\n\r\n    labels.push({\r\n      discriminator: 'positionedlabels',\r\n      type: 'x',\r\n      labels: [{ position: 0.5, content: 'umap-x' }],\r\n    })\r\n  } else if (axis === 'y') {\r\n    const data = embedding.map((arr) => arr[0]);\r\n    const scale = scaleLinear().domain(getMinMax(data)).range([0, 1]);\r\n    Y = data.map((arr, i) => ({ y: scale(arr), x: Y_in[i].x }));\r\n\r\n    labels.push({\r\n      discriminator: 'positionedlabels',\r\n      type: 'y',\r\n      labels: [{ position: 0.5, content: 'umap-y' }],\r\n    })\r\n  } else if (axis === 'xy') {\r\n    Y = embedding.map((arr) => ({ x: arr[0], y: arr[1] }));\r\n    Y = normalizeVectors01(Y);\r\n\r\n    labels.push({\r\n      discriminator: 'positionedlabels',\r\n      type: 'x',\r\n      labels: [{ position: 0.5, content: 'umap-x' }],\r\n    })\r\n    labels.push({\r\n      discriminator: 'positionedlabels',\r\n      type: 'y',\r\n      labels: [{ position: 0.5, content: 'umap-y' }],\r\n    })\r\n  }\r\n\r\n  const [worldX, worldY] = scaleToWorld(area);\r\n\r\n  self.postMessage({\r\n    type: 'message',\r\n    message: 'Force layout ...',\r\n  });\r\n\r\n  console.log(Y);\r\n\r\n  self.postMessage({\r\n    type: 'finish',\r\n    Y: Y.map((node) => ({\r\n      x: axis !== 'y' ? worldX(node.x) : node.x,\r\n      y: axis !== 'x' ? worldY(node.y) : node.y,\r\n    })),\r\n    labels,\r\n  });\r\n};\r\n"],"names":["scaleToWorld","area","worldX","scaleLinear","domain","range","x","width","worldY","y","height","forceNormalizationNew","factor","scaleX","scaleY","POINT_RADIUS","getMinMax","values","minX","Number","MAX_SAFE_INTEGER","maxX","MIN_SAFE_INTEGER","forEach","sample","Math","min","max","getBounds","spatial","minY","maxY","centerX","centerY","extentX","extentY","spread","center","radius","random","scaleInto","source","bounds","translateX","xScale","yScale","map","value","translateY","normalizeVectors01","positions","scale","pointInPolygon","testx","testy","polygon","intersections","i","j","length","prevX","prevY","self","onmessage","data","X","D","N","type","Y_in","axis","Y","postMessage","message","umap","UMAP","nComponents","nEpochs","nNeighbors","embedding","fit","labels","arr","push","discriminator","position","content","console","log","node"],"mappings":"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"}
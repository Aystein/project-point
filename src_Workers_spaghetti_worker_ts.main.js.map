{"version":3,"file":"src_Workers_spaghetti_worker_ts.main.js","sources":["./node_modules/lodash/mapValues.js","./src/Layouts/ForceUtil.ts","./src/Layouts/Globals.ts","./src/Util.ts","./src/Workers/spaghetti.worker.ts"],"sourcesContent":["var baseAssignValue = require('./_baseAssignValue'),\n    baseForOwn = require('./_baseForOwn'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n","import { ScaleLinear, scaleLinear } from 'd3-scale';\nimport { IRectangle } from '../WebGL/Math/Rectangle';\nimport { Simulation, SimulationLinkDatum } from 'd3-force';\nimport { POINT_RADIUS } from './Globals';\n\nexport function scaleToWorld(\n  area: IRectangle\n): [\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n] {\n  const worldX = scaleLinear()\n    .domain([0, 1])\n    .range([area.x, area.x + area.width]);\n\n  const worldY = scaleLinear()\n    .domain([0, 1])\n    .range([area.y, area.y + area.height]);\n\n  return [worldX, worldY];\n}\n\nexport function forceNormalizationNew(\n  area: IRectangle\n): [\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n  ScaleLinear<number, number>,\n  number\n] {\n  const factor = 500 / area.width;\n\n  const scaleX = scaleLinear()\n    .domain([0, 1])\n    .range([0, area.width * factor]);\n\n  const scaleY = scaleLinear()\n    .domain([0, 1])\n    .range([0, area.height * factor]);\n\n  const worldX = scaleLinear()\n    .domain([0, 1])\n    .range([area.x + area.width * 0.01, area.x + area.width * 0.99]);\n\n  const worldY = scaleLinear()\n    .domain([0, 1])\n    .range([area.y + area.height * 0.01, area.y + area.height * 0.99]);\n\n  return [scaleX, scaleY, worldX, worldY, POINT_RADIUS * factor];\n}\n\nexport function forceNormalization(\n  area: IRectangle\n): [ScaleLinear<number, number>, ScaleLinear<number, number>, number] {\n  const factor = 500 / area.width;\n\n  const scaleX = scaleLinear()\n    .domain([area.x, area.x + area.width])\n    .range([0, area.width * factor]);\n\n  const scaleY = scaleLinear()\n    .domain([area.y, area.y + area.height])\n    .range([0, area.height * factor]);\n\n  return [scaleX, scaleY, POINT_RADIUS * factor];\n}\n\nexport function convergeLayout<A, B extends SimulationLinkDatum<A>>(\n  simulation: Simulation<A, B>\n) {\n  for (\n    var i = 0,\n      n = Math.ceil(\n        Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())\n      );\n    i < n;\n    ++i\n  ) {\n    // console.log(\"TICK\")\n    simulation.tick();\n  }\n}\n","export const POINT_RADIUS = 0.012;\n","import { EntityId } from '@reduxjs/toolkit';\nimport { Boundaries, VectorLike } from './Interfaces';\nimport { ScaleLinear, scaleLinear } from 'd3-scale';\nimport { Rectangle } from './WebGL/Math/Rectangle';\n\nexport function isEntityId(value): value is EntityId {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\nexport function getMinMax(values: number[]) {\n  let minX = Number.MAX_SAFE_INTEGER;\n  let maxX = Number.MIN_SAFE_INTEGER;\n\n  values.forEach((sample) => {\n    minX = Math.min(minX, sample);\n    maxX = Math.max(maxX, sample);\n  });\n\n  return [minX, maxX];\n}\n\nexport function getBounds(spatial: VectorLike[]): Boundaries {\n  // Get rectangle that fits around data set\n  let minX = 1000;\n  let maxX = -1000;\n  let minY = 1000;\n  let maxY = -1000;\n\n  spatial.forEach((sample) => {\n    minX = Math.min(minX, sample.x);\n    maxX = Math.max(maxX, sample.x);\n    minY = Math.min(minY, sample.y);\n    maxY = Math.max(maxY, sample.y);\n  });\n\n  return {\n    minX,\n    maxX,\n    minY,\n    maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    extentX: maxX - minX,\n    extentY: maxY - minY,\n  };\n}\n\nexport function spread(center: number, radius: number) {\n  return center - radius + Math.random() * 2 * radius;\n}\n\nexport function scaleInto(source: VectorLike[]): [VectorLike[], number] {\n  const bounds = getBounds(source);\n  const center = 10;\n\n  if (bounds.extentX >= bounds.extentY) {\n    const translateX = center - bounds.centerX;\n    const xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([bounds.minX + translateX, bounds.maxX + translateX])\n    const yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([center - bounds.extentY / 2, center + bounds.extentY / 2])\n\n    return [source.map((value) => ({\n      x: xScale(value.x),\n      y: yScale(value.y)\n    })), bounds.extentX];\n  }\n\n  if (bounds.extentX < bounds.extentY) {\n    const translateY = center - bounds.centerY;\n    const xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([center - bounds.extentX / 2, center + bounds.extentX / 2])\n    const yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([bounds.minY + translateY, bounds.maxY + translateY])\n\n    return [source.map((value) => ({\n      x: xScale(value.x),\n      y: yScale(value.y)\n    })), bounds.extentY];\n  }\n}\n\nexport function normalizeVectors(positions: VectorLike[]) {\n  const bounds = getBounds(positions);\n\n  let xScale: ScaleLinear<number, number>;\n  let yScale: ScaleLinear<number, number>;\n\n\n\n  if (bounds.extentX >= bounds.extentY) {\n    const scale = bounds.extentY / bounds.extentX;\n    xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([-bounds.extentX / 2, bounds.extentX / 2]);\n    yScale = scaleLinear()\n      .domain([bounds.minY, bounds.maxY])\n      .range([(-bounds.extentY / 2) * scale, (bounds.extentY / 2) * scale]);\n  } else {\n    const scale = bounds.extentX / bounds.extentY;\n    xScale = scaleLinear()\n      .domain([bounds.minX, bounds.maxX])\n      .range([(-bounds.extentX / 2) * scale, (bounds.extentX / 2) * scale]);\n    yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([-bounds.extentY / 2, bounds.extentY / 2]);\n  }\n\n  return positions.map((value) => ({ x: xScale(value.x), y: yScale(value.y) }));\n}\n\nexport function normalizeVectors01(positions: VectorLike[]) {\n  const bounds = getBounds(positions);\n\n  let xScale: ScaleLinear<number, number>;\n  let yScale: ScaleLinear<number, number>;\n\n  if (bounds.extentX >= bounds.extentY) {\n    const scale = bounds.extentY / bounds.extentX;\n    xScale = scaleLinear().domain([bounds.minX, bounds.maxX]).range([0, 1]);\n    yScale = scaleLinear()\n      .domain([bounds.minY, bounds.maxY])\n      .range([1 - scale, scale]);\n  } else {\n    const scale = bounds.extentX / bounds.extentY;\n    xScale = scaleLinear()\n      .domain([bounds.minX, bounds.maxX])\n      .range([1 - scale, scale]);\n    yScale = scaleLinear().domain([bounds.minY, bounds.maxY]).range([0, 1]);\n  }\n\n  return positions.map((value) => ({ x: xScale(value.x), y: yScale(value.y) }));\n}\n\n/**\n * Performs a test if a point is inside a polygon based on the idea from\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n *\n * This method will not need the same start/end point since it wraps around the edges of the array\n *\n * @param {*} test a point to test against\n * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]\n * @returns true if the point lies inside the polygon, false otherwise\n */\nexport function pointInPolygon(testx, testy, polygon) {\n  let intersections = 0;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i, i += 1) {\n    const [prevX, prevY] = polygon[j];\n    const [x, y] = polygon[i];\n\n    // count intersections\n    if (\n      y > testy != prevY > testy &&\n      testx < ((prevX - x) * (testy - y)) / (prevY - y) + x\n    ) {\n      intersections += 1;\n    }\n  }\n\n  // point is in polygon if intersection count is odd\n  return intersections & 1;\n}\n","/* eslint-disable @typescript-eslint/no-loop-func */\n/* eslint-disable no-loop-func */\n/* eslint-disable no-restricted-globals */\nimport groupBy from 'lodash/groupBy';\nimport keys from 'lodash/keys';\nimport { VectorLike } from '../Interfaces';\nimport {\n  forceNormalizationNew,\n} from '../Layouts/ForceUtil';\nimport { LabelContainer } from '../Store/interfaces';\nimport { IRectangle } from '../WebGL/Math/Rectangle';\nimport mapValues from 'lodash/mapValues';\nimport { nanoid } from '@reduxjs/toolkit';\nimport { stratify, treemap, treemapSlice } from 'd3-hierarchy';\nimport { POINT_RADIUS } from '../Layouts/Globals';\nimport { scaleLinear } from 'd3-scale';\nimport { getMinMax } from '../Util';\n\ninterface Props {\n  data: {\n    X: { [key: string]: string | number }[];\n    area: IRectangle;\n    features: string[];\n    secondary: string;\n    type: string;\n    axis: 'x' | 'y';\n    Y_in: VectorLike[];\n  };\n}\n\nvar nest = function (seq, fns: ((v) => unknown)[]) {\n  if (!fns.length)\n    return seq;\n  var first = fns[0];\n  var rest = fns.slice(1);\n  return mapValues(groupBy(seq, first), function (value) {\n    return nest(value, rest)\n  });\n};\n\nfunction position(min: number, max: number, i: number, n: number) {\n  const step = (max - min) / n;\n\n  return {\n    min: min + i * step,\n    max: min + (i + 1) * step,\n  }\n}\n\nself.onmessage = ({\n  data: { X, area, type, features, axis, secondary },\n}: Props) => {\n  if (type !== 'init') {\n    return;\n  }\n\n  const labels: LabelContainer = {\n    discriminator: 'positionedlabels',\n    type: axis,\n    labels: [],\n  };\n\n  const relativeIndices = X.map((value, i) => ({\n    relativeIndex: i,\n    value,\n  }));\n\n  const N = X.length;\n  const groups = groupBy(relativeIndices, (value) => {\n    return value.value[features[0]];\n  });\n\n  const hierarchy = nest(relativeIndices, features.map((feature) => {\n    return (value) => {\n      return value.value[feature];\n    }\n  }))\n\n  const maxGroupLengths = features.map((feature) => {\n    return new Set(X.map((value) => value[feature])).size\n  })\n\n  const Y = new Array<VectorLike>(N);\n\n  const [scaleX, scaleY, worldX, worldY, radius] = forceNormalizationNew(area);\n\n  let stepSize = 1 / (keys(groups).length + 1);\n  let centerX = stepSize;\n\n  const maxGroupLength = Math.max(...keys(groups).map((key) => groups[key].length))\n\n  let totalHeight = 0;\n\n  const linearScale = scaleLinear().domain(getMinMax(X.map((value) => value[secondary] as number))).range(axis === 'y' ? [area.x, area.x + area.width] : [area.y, area.y + area.height])\n\n  function traverse(group) {\n    const len = keys(group).length;\n    let y = 0;\n\n    keys(group).forEach((value) => {\n      const set = group[value];\n\n      if (Array.isArray(set)) {\n        // one line\n\n        y += POINT_RADIUS * 2;\n        set.forEach((item) => {\n          const secAxis = linearScale(item.value[secondary]);\n          const primary = totalHeight + y;\n\n          Y[item.relativeIndex] = { x: axis === 'y' ? secAxis : primary, y: axis === 'y' ? primary : secAxis };\n        })\n      } else {\n        // traverse\n        traverse(set);\n      }\n    })\n\n    totalHeight += y;\n    totalHeight += POINT_RADIUS * 5;\n  }\n\n  traverse(hierarchy);\n\n\n  /**for (const key of keys(groups)) {\n    const group = groups[key];\n\n    labels.labels.push({ position: centerX, content: key });\n\n    group.forEach((item, i) => {\n      let secondary = i / maxGroupLength;\n      let primary = centerX;\n\n      if (features.length > 1) {\n        // hierarchy[features[0]][features[1]]\n      }\n\n      Y[item.relativeIndex] = { x: axis === 'y' ? secondary : primary, y: axis === 'y' ? primary : secondary };\n    });\n\n    centerX += stepSize;\n  }**/ \n\n  self.postMessage({\n    type: 'finish',\n    // @ts-ignore\n    Y: Y.map((value) => ({ x: value.x, y: axis === 'y' ? area.y + value.y : value.y })),\n    labels: [labels],\n  });\n};\n"],"names":["baseAssignValue","baseForOwn","baseIteratee","module","exports","object","iteratee","result","value","key","scaleToWorld","area","worldX","scaleLinear","domain","range","x","width","worldY","y","height","forceNormalizationNew","factor","scaleX","scaleY","POINT_RADIUS","getMinMax","values","minX","Number","MAX_SAFE_INTEGER","maxX","MIN_SAFE_INTEGER","forEach","sample","Math","min","max","getBounds","spatial","minY","maxY","centerX","centerY","extentX","extentY","spread","center","radius","random","scaleInto","source","bounds","translateX","xScale","yScale","map","translateY","normalizeVectors01","positions","scale","pointInPolygon","testx","testy","polygon","intersections","i","j","length","prevX","prevY","nest","seq","fns","first","rest","slice","self","onmessage","data","X","type","features","axis","secondary","relativeIndices","relativeIndex","N","groups","hierarchy","feature","Set","size","Y","Array","totalHeight","linearScale","traverse","group","set","isArray","item","secAxis","primary","postMessage","labels","discriminator"],"mappings":"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"}